
a:((0 0);(0 1);(0 2);(0 3);(0 4))
a:((0 0);(-3 4);(0 5);(-5 0))
a:((0 0);(0 100);(100 0);(100 100))
a:((5 6);(6 5);(7 6);(6 7);(7 8);(8 7))
nc2:{x*(x-1)%2}
distance:{[x;y] :enlist[(x;y)]!enlist (((y[0]-x[0])xexp 2)+(y[1]-x[1])xexp 2) xexp 0.5}
dist_dictionary:raze{[i] raze distance[a[i];]each a except enlist a[i]} each til count a
sum raze nc2 each value each count each' group each raze each value group (!).(z;dist_dictionary[z:distinct asc each key dist_dictionary])

/
So here is mine:
d:(0 0;-3 4;0 5;-5 0)
sum {x*(x-1)%2} each raze {value count each group `int$sum flip ((d x)-/:(d except enlist d x)) xexp 2} each til count d

Akash optimized it in many ways, here is the fastest one:
d:(0 0;-3 4;0 5;-5 0)
sum {x*(x-1)%2} raze deltas each ({where differ asc sum each x}each n*n:d-/:'d@m _/:m:til l),'-1+l:count d
\


/
// ---- HELPER FUNCTIONS
dist:{[x;y] sqrt sum ((y[0]-x[0]) xexp 2;(y[1]-x[1]) xexp 2)};
nC2:{[n] n*(n-1)%2};

// ---- INPUT DATA(try one at a time)
points:(5 6;6 5;7 6;6 7;7 8;8 7)    / will give 12
points:(0 0;-3 4;0 5;-5 0)          / will give 3
points:(0 0;0 100;100 0;100 100)    / will give 4
points:(0 0;0 1;0 2;0 3;0 4)        / will give 4
points:(0 0;0 1;0 3)                / will give 0

// ---- CALCULATION
dist_matrix:points {[x;y] dist[y;]each x}/:points;
sum {[lst] sum nC2 each value @[(a)!(count a:distinct lst)#0;lst;+;1]} each dist_matrix



\
